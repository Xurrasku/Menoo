"""
Authentication utilities for FastAPI JWT authentication.
"""
import os
from datetime import datetime, timedelta
from typing import Optional
from jose import JWTError, jwt
from passlib.context import CryptContext
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from pydantic import BaseModel

# Load environment variables
from dotenv import load_dotenv
load_dotenv()

# Try to import Supabase client
try:
    from supabase import create_client, Client
    SUPABASE_AVAILABLE = True
except ImportError:
    SUPABASE_AVAILABLE = False
    Client = None

# Password hashing context
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# OAuth2 scheme - tokenUrl is the endpoint where users login
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="login")

# JWT Configuration
SECRET_KEY = os.getenv("JWT_SECRET_KEY", "your-secret-key-change-in-production")
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = int(os.getenv("JWT_ACCESS_TOKEN_EXPIRE_MINUTES", "1440"))  # Default 24 hours


class Token(BaseModel):
    """Token response model."""
    access_token: str
    token_type: str


class TokenData(BaseModel):
    """Token data model."""
    username: Optional[str] = None


class User(BaseModel):
    """User model."""
    username: str
    email: Optional[str] = None
    disabled: Optional[bool] = False


class UserInDB(User):
    """User in database model (includes hashed password)."""
    hashed_password: str


def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verify a password against a hash."""
    return pwd_context.verify(plain_password, hashed_password)


def get_password_hash(password: str) -> str:
    """Hash a password."""
    return pwd_context.hash(password)


def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    """
    Create a JWT access token.
    
    Args:
        data: Dictionary containing the data to encode in the token (typically user info)
        expires_delta: Optional timedelta for token expiration. If None, uses default from config.
    
    Returns:
        Encoded JWT token string
    """
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt


def decode_token(token: str) -> Optional[dict]:
    """
    Decode and verify a JWT token.
    
    Args:
        token: JWT token string
    
    Returns:
        Decoded token payload as dictionary, or None if invalid
    """
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return payload
    except JWTError:
        return None


async def get_current_user(token: str = Depends(oauth2_scheme)) -> dict:
    """
    Dependency to get the current authenticated user from Supabase Auth JWT token.
    
    This function validates the Supabase Auth token and returns the user data.
    Works with tokens generated by Supabase Auth in the frontend.
    
    Usage:
        @app.get("/protected")
        async def protected_route(current_user: dict = Depends(get_current_user)):
            return {"user": current_user}
    
    Args:
        token: JWT token from Authorization header (Supabase Auth token from frontend)
    
    Returns:
        Dictionary containing user data from Supabase Auth
    
    Raises:
        HTTPException: If token is invalid or expired
    """
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    
    # Try to validate with Supabase Auth (production mode)
    if SUPABASE_AVAILABLE:
        try:
            # Get Supabase URL and anon key for user token validation
            # Use anon key (not service role) to validate user tokens
            supabase_url = os.getenv("NEXT_PUBLIC_SUPABASE_URL") or os.getenv("SUPABASE_URL")
            supabase_anon_key = os.getenv("NEXT_PUBLIC_SUPABASE_ANON_KEY") or os.getenv("SUPABASE_ANON_KEY")
            
            if supabase_url and supabase_anon_key:
                # Create client with anon key for user token validation
                user_supabase = create_client(supabase_url, supabase_anon_key)
                
                # Verify token and get user from Supabase Auth
                user_response = user_supabase.auth.get_user(jwt=token)
                
                if user_response and hasattr(user_response, 'user') and user_response.user:
                    user = user_response.user
                    return {
                        "user_id": user.id,
                        "email": user.email,
                        "username": user.email.split("@")[0] if user.email else None,  # Use email prefix as username
                        "email_verified": user.email_confirmed_at is not None,
                        "created_at": user.created_at,
                    }
        except Exception as e:
            # Token invalid or expired - try fallback or raise exception
            pass
    
    # Fallback: Try to decode as our own JWT (for backward compatibility)
    payload = decode_token(token)
    if payload is None:
        raise credentials_exception
    
    username: str = payload.get("sub")
    if username is None:
        raise credentials_exception
    
    # Return user data from token (legacy mode)
    return {
        "username": username,
        "email": payload.get("email"),
        "user_id": payload.get("user_id"),
    }


def _get_supabase_client() -> Optional[Client]:
    """
    Create Supabase client from environment variables.
    
    Returns:
        Supabase Client if credentials available, None otherwise
    """
    if not SUPABASE_AVAILABLE:
        return None
    
    supabase_url = os.getenv("NEXT_PUBLIC_SUPABASE_URL") or os.getenv("SUPABASE_URL")
    supabase_key = os.getenv("SUPABASE_SERVICE_ROLE_KEY")
    
    if not supabase_url or not supabase_key:
        return None
    
    try:
        return create_client(supabase_url, supabase_key)
    except Exception:
        return None


# Example user database (for local development only)
# In production, uses Supabase database
# Note: Password hash is computed lazily to avoid issues during module import
_fake_users_db_cache: Optional[dict] = None

def _get_fake_users_db() -> dict:
    """
    Get fake users database with lazy password hashing.
    
    Password hash is computed only when first accessed to avoid issues
    during module import (bcrypt initialization can fail during import).
    """
    global _fake_users_db_cache
    if _fake_users_db_cache is None:
        _fake_users_db_cache = {
            "admin": {
                "username": "admin",
                "email": "admin@example.com",
                "hashed_password": get_password_hash("admin123"),  # Computed lazily
                "disabled": False,
            }
        }
    return _fake_users_db_cache


def get_user(username: str) -> Optional[UserInDB]:
    """
    Get user from database by username.
    
    Uses Supabase in production if configured, otherwise falls back to fake_users_db for development.
    
    Args:
        username: Username to lookup
    
    Returns:
        UserInDB object if found, None otherwise
    """
    # Try Supabase first (production mode)
    supabase = _get_supabase_client()
    if supabase:
        try:
            response = supabase.table("api_users").select("*").eq("username", username).single().execute()
            if response.data:
                user_data = response.data
                return UserInDB(
                    username=user_data["username"],
                    email=user_data.get("email"),
                    disabled=user_data.get("disabled", False),
                    hashed_password=user_data["hashed_password"]
                )
        except Exception:
            # User not found or error querying Supabase
            pass
    
    # Fallback to fake_users_db (development mode)
    fake_db = _get_fake_users_db()
    if username in fake_db:
        user_dict = fake_db[username]
        return UserInDB(**user_dict)
    
    return None


def authenticate_user(username: str, password: str) -> Optional[UserInDB]:
    """
    Authenticate a user by username and password.
    
    Args:
        username: Username
        password: Plain text password
    
    Returns:
        UserInDB object if authentication successful, None otherwise
    """
    user = get_user(username)
    if not user:
        return None
    if not verify_password(password, user.hashed_password):
        return None
    return user
